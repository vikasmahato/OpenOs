#include <arch/i386/idt.h>
#include <arch/i386/interrupts.h>
#include <asm.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include <string.h>
/*
 * This file contains code for the reserved interrupt handlers
 * and mechanism for device drivers to add their own interrupt handlers.
 * Eg: kb.cpp and timer.cpp
 * Documentation resource: https://wiki.osdev.org/Exceptions
 * 
 * Exceptions are generated by the CPU when an 'error' occurs. Some exceptions are not 
 * really errors in most cases, such as page faults. Exceptions are a type of interrupt.
 * Exceptions are classified as:
 * - Faults: These can be corrected and the program may continue as if nothing happened.
 * - Traps: Traps are reported immediately after the execution of the trapping instruction.
 * - Aborts: Some severe unrecoverable error. 
 */
interrupt_handler_t InterruptHandler::interrupt_handlers[] = {0};

InterruptHandler::InterruptHandler() {
  register_interrupt_handler(0, divideByZeroExceptionHandler);
  register_interrupt_handler(1, debugExceptionHandler);
  register_interrupt_handler(2, nonMaskableInterruptExceptionHandler);
  register_interrupt_handler(3, breakpointExceptionHandler);
  register_interrupt_handler(4, intoDetectedOverflowExceptionHandler);
  register_interrupt_handler(5, outOfBoundsExceptionHandler);
  register_interrupt_handler(6, invalidOpcodeExceptionHandler);
  register_interrupt_handler(7, noCoprocessorExceptionHandler);
  register_interrupt_handler(8, doubleFaultExceptionHandler);
  register_interrupt_handler(9, coprocessorSegmentOverrunExceptionHandler);
  register_interrupt_handler(10, badTssExceptionHandler);
  register_interrupt_handler(11, segmentNotPresentExceptionHandler);
  register_interrupt_handler(12, stackFaultExceptionHandler);
  register_interrupt_handler(13, generalProtectionFaultExceptionHandler);
  register_interrupt_handler(14, pageFaultExceptionHandler);
  register_interrupt_handler(15, unkownInterruptExceptionHandler);
  register_interrupt_handler(16, coprocessorFaultExceptionHandler);
  register_interrupt_handler(17, alignmentCheckExceptionHandler);
  register_interrupt_handler(18, machineCheckExceptionHandler);
}

bool InterruptHandler::register_interrupt_handler(uint32_t idt_index, interrupt_handler_t handler) {
  if (idt_index >= IDT_NUM_ENTRIES) {
    return false;
  }
  
  if (interrupt_handlers[idt_index] != NULL) {
    return false;
  }

  interrupt_handlers[idt_index] = handler;
  return true;
}

void InterruptHandler::fault_handler(struct regs *r) {
  if(r->idt_index <19) {
    void (*handler)(struct regs * r);

    handler = interrupt_handlers[r->idt_index];

    if (handler) {
      handler(r);
    }
  } else {
    printf("Unhandled Exception. System Halted! %d\n", r->idt_index);
    for (;;);
  }
}

void InterruptHandler::irq_handler(struct regs *r) {
  // Blank function pointer
  void (*handler)(struct regs * r);

  // If there's a custom handler to handle the IRQ, handle it
  handler = interrupt_handlers[r->idt_index];
  if (handler) {
    handler(r);
  }

  // If the IDT entry that was invoked was greater than 40, sends an EOI
  // to the slave controller
  if (r->idt_index >= 40) {
    outb(0xA0, 0x20);
  }

  // Sends an EOI to the master interrupt controller
  outb(0x20, 0x20);
}

void InterruptHandler::runInterruptHandler(struct regs* r) {
  size_t idt_index = r->idt_index;
  if (idt_index < 32) {
    fault_handler(r);
    return;
  }

  if (idt_index >= 32 && idt_index <= 47) {
    irq_handler(r);
    return;
  }

  if (interrupt_handlers[r->idt_index] != NULL) {
    interrupt_handlers[r->idt_index](r);
  }
}

void InterruptHandler::divideByZeroExceptionHandler(struct regs* r) {
  /*
   * The Divide-by-zero Error occurs when dividing any number by 0 using 
   * the DIV or IDIV instruction. Many OS developers use this exception 
   * to test whether their exception handling code works. This exception 
   * may also occur when the result is too large to be represented in the 
   * destination.The saved instruction pointer points to the DIV or IDIV 
   * instruction which caused the exception. 
   */
  printf("Division by zero exception\n");
}

void InterruptHandler::debugExceptionHandler(struct regs* r) {
  printf("Debug exception\n");
}

void InterruptHandler::nonMaskableInterruptExceptionHandler(struct regs* r) {
  printf("Non maskable interrupt\n");
}

void InterruptHandler::breakpointExceptionHandler(struct regs* r) {
  printf("Breakpoint exception\n");
}

void InterruptHandler::intoDetectedOverflowExceptionHandler(struct regs* r) {
  printf("Into detected overflow\n");
}

void InterruptHandler::outOfBoundsExceptionHandler(struct regs* r) {
  printf("Out of bounds exception\n");
}

void InterruptHandler::invalidOpcodeExceptionHandler(struct regs* r) {
  printf("Invalid opcode exception\n");
}

void InterruptHandler::noCoprocessorExceptionHandler(struct regs* r) {
  printf("No coprocessor exception\n");
}

void InterruptHandler::doubleFaultExceptionHandler(struct regs* r) {
  /*
   * A Double Fault occurs when an exception is unhandled or when an 
   * exception occurs while the CPU is trying to call an exception handler. 
   * Normally, two exception at the same time are handled one after another, 
   * but in some cases that is not possible. 
   * For example, if a page fault occurs, but the exception handler is 
   * located in a not-present page, two page faults would occur and neither 
   * can be handled. A double fault would occur.
   * A double fault will always generate an error code with a value of zero. 
   * The saved instruction pointer is undefined. 
   * A double fault cannot be recovered. The faulting process must be terminated. 
   */
  printf("Double fault\n");
  for (;;); //TODO use asm hlt or even better use kpanic
}

void InterruptHandler::coprocessorSegmentOverrunExceptionHandler(struct regs* r) {
  /*
   * When the FPU was still external to the processor, 
   * it had separate segment checking in protected mode. 
   * Since the 486 this is handled by a GPF instead like 
   * it already did with non-FPU memory accesses. 
   */
  printf("Coprocessor segment overrun\n");
}

void InterruptHandler::badTssExceptionHandler(struct regs* r) {
  printf("Bad TSS\n");
}

void InterruptHandler::segmentNotPresentExceptionHandler(struct regs* r) {
  printf("Segment not present\n");
}

void InterruptHandler::stackFaultExceptionHandler(struct regs* r) {
  printf("Stack fault\n");
}

void InterruptHandler::generalProtectionFaultExceptionHandler(struct regs* r) {
  printf("General protection fault\n");
}

void InterruptHandler::pageFaultExceptionHandler(struct regs* r) {
  /*
   * A Page Fault occurs when:
   * - A page directory or table entry is not present in physical memory.
   * - Attempting to load the instruction TLB with a translation for a non-executable page.
   * - A protection check (privileges, read/write) failed.
   * - A reserved bit in the page directory or table entries is set to 1. 

   * The saved instruction pointer points to the instruction which caused the exception.
   * The Page Fault sets an error code: 
   *  31              4               0
   * +---+--  --+---+---+---+---+---+---+
   * |   Reserved   | I | R | U | W | P |
   * +---+--  --+---+---+---+---+---+---+
   * 
   * P 	1 bit 	Present 	When set, the page fault was caused by a page-protection violation. When not set, it was caused by a non-present page.
   * W 	1 bit 	Write 	When set, the page fault was caused by a write access. When not set, it was caused by a read access.
   * U 	1 bit 	User 	When set, the page fault was caused while CPL = 3. This does not necessarily mean that the page fault was a privilege violation.
   * R 	1 bit 	Reserved write 	When set, one or more page directory entries contain reserved bits which are set to 1. This only applies when the PSE or PAE flags in CR4 are set to 1.
   * I 	1 bit 	Instruction Fetch 	When set, the page fault was caused by an instruction fetch. This only applies when the No-Execute bit is supported and enabled. 
   */
  printf("Page Fault was caused because: ");
  /* The faulting address is stored in the CR2 register. */
  uint32_t faulting_address;
  asm volatile("mov %%cr2, %0" : "=r" (faulting_address));

  /* The error code gives us detailing og what happened. */
	int present	  = r->err_code & 0x1;	  /* Page not present */
	int rw		    = r->err_code & 0x2;		/* Write operation? */
	int us		    = r->err_code & 0x4;		/* Processor was in user-mode? */
	int reserved	= r->err_code & 0x8;		/* Overwritten CPU-reserved bits of page entry? */
	int id		    = r->err_code & 0x10;		/* Caused by an instruction fetch */

  if (!present)
		printf("page was not present ");
	if (rw)
		printf("trying to write at read-only location");
	if (us)
		printf("user-mode ");
	if (reserved)
		printf("Reserved write");
  if(id)
    printf("Instruction fetch.");

  printf("At address %lx\n", faulting_address);
}

void InterruptHandler::unkownInterruptExceptionHandler(struct regs* r) {
  printf("Unknown interrupt exception\n");
}

void InterruptHandler::coprocessorFaultExceptionHandler(struct regs* r) {
  printf("Coprocessor fault\n");
}

void InterruptHandler::alignmentCheckExceptionHandler(struct regs* r) {
  /*
   * An Alignment Check exception occurs when alignment checking is enabled 
   * and an unaligned memory data reference is performed. Alignment checking is only performed in CPL 3.
   * Alignment checking is disabled by default. To enable it, set the CR0.AM and RFLAGS.AC bits both to 1.
   * The saved instruction pointer points to the instruction which caused the exception. 
   */
  printf("Alignment check exception\n");
}

void InterruptHandler::machineCheckExceptionHandler(struct regs* r) {
  /*
   * The Machine Check exception is model specific and processor implementations 
   * are not required to support it. It uses model-specific registers to provide 
   * error information. It is disabled by default. To enable it, set the CR4.MCE 
   * bit to 1.Machine check exceptions occur when the processor detects internal 
   * errors, such as bad memory, bus errors, cache errors, etc. The value of the 
   * saved instruction pointer depends on the implementation and the exception. 
   */
  printf("Machine check exception\n");
}

extern "C" void run_interrupt_handler(struct regs* r) {
  InterruptHandler::runInterruptHandler(r);
}